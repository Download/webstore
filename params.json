{"name":"Webstore","tagline":"One stop shop for Web Storage API compliant persistence.","body":"# webstore <sub><sup>v0.9.0</sup></sub>\r\n**One-stop shop for [Web Storage API](http://www.w3.org/TR/webstorage/) compliant persistence.**\r\n[Project website](http://download.github.io/webstore)\r\n\r\nWebStore builds on top of [MemoryStorage](https://download.github.io/memorystorage), \r\nadding persistence to it in the form of `load` and `save` methods.\r\n\r\nFor now loading and saving is explicit, so you will be able to fully control when it happens. \r\nI am thinking of some `autoPersist` option (maybe together with a strategy, or some settings) \r\nto have WebStore handle it for you, but that functionality is not there yet.\r\n\r\nWebStore was built for performance. As it basically performs all operations in-memory, the overhead\r\nof using it should be near zero as long as you don't save or load. When you do save or load, `localStorage`\r\nis used so you will get the normal performance associated with such I/O. \r\n\r\nHaving the data actually survive page reloads and browser sessions is a secondary concern. Users can wipe \r\ntheir browser caches and use private browsing modes, so we need to consider the option of the data\r\nbeing gone anyway. I recommend storing the data on the server by means of an Ajax call if it is really\r\nimportant and only using local storage as a glorified cache.\r\n\r\nCurrently, WebStore does not handle synchronization of data between multiple tabs. This\r\nmeans you should either limit your use to single-page-apps, use isolated stores for different\r\npages, or come up with some synchronization system yourself.\r\n\r\n\r\n## Download\r\n* [webstore.js](https://cdn.rawgit.com/download/webstore/0.9.0/dist/webstore.js) (~10kB, commented)\r\n* [webstore.min.js](https://cdn.rawgit.com/download/webstore/0.9.0/dist/webstore.min.js) (~3kB, minified)\r\n* [webstore.min.js.map](https://cdn.rawgit.com/download/webstore/0.9.0/dist/webstore.min.js.map) (~3kB, debug map file)\r\n\r\n## Include on your page\r\n`webstore` can be used directly from CDN, or from a local script file.\r\n\r\n### CDN\r\n```xml\r\n<script src=\"https://cdn.rawgit.com/download/webstore/0.9.0/dist/webstore.min.js\"></script>\r\n```\r\n\r\n### Local script file\r\nDownload webstore.min.js, place it in a folder `lib` in the root of your website and include it like this:\r\n```xml\r\n<script src=\"/lib/webstore.min.js\"></script>\r\n```\r\n\r\n### Use with NPM or Bower\r\n`npm install webstore`\r\n\r\n## Creating a webstore object\r\nThe `WebStore` function creates (or returns) a storage object implementing the W3C Web Storage API.\r\nBy default, scripts share a `global` storage object, so scripts can access and mutate each other's store\r\nobject. To have WebStore create a storage object that is isolated from other scripts, you pass in\r\na unique ID which acts as a namespace:\r\n\r\n```javascript\r\nvar isolated = new WebStore('my-app'); // isolated from other scripts, recommended.\r\n```\r\n\r\nIf you don't pass in an ID, or use the ID `'global'`, you get a globally shared storage object:\r\n\r\n```javascript\r\nvar global = new WebStore(); // will default to a globally shared storage object.\r\nvar global2 = new WebStore('global'); // effectively same as above\r\n```\r\n\r\nFor your convenience, the constructor permits `new`-less invocation:\r\n```javascript\r\nvar store = WebStore('my-store');\r\nvar global = WebStore();\r\n```\r\n\r\nInstances of `WebStore` expose an immutable `id` property that is set to\r\nthe id the store was created with:\r\n\r\n```javascript\r\nalert(store.id); // alerts 'my-store'\r\nalert(global.id); // alerts 'global'\r\n```\r\n\r\n## Loading the store\r\nWebStore builds on top of [MemoryStorage](https://download.github.io/memorystorage). \r\nAs such, all operations are performed in local memory and super-fast. But it also\r\nmeans that we have to make sure our changes are loaded before we start, and saved\r\nonce we are done. I'm thinking about and experimenting with mechanisms to take care\r\nof this for you, but for now you will explicitly have to call the `load` method yourself.\r\n\r\n```javascript\r\nvar store = new WebStore('my-store');\r\nstore.load();\r\n```\r\n\r\n## Using the store\r\nOnce you have loaded the store, you can use it just as you would `localStorage`\r\nor any other store implementing Web Storage:\r\n\r\n\r\n```javascript\r\nstore.setItem('myString', 'Hello WebStore!');\r\nstore.myObject = JSON.stringify({my: 'object'}));\r\nalert(store.getItem('My string')); // alerts 'Hello MemoryStorage!'\r\nalert(store['My string']); // alerts 'Hello MemoryStorage!'\r\nalert(store.length); // alerts '2'\r\nalert(store.key(1)); // alerts 'My object'\r\nstore.removeItem('My string');\r\nalert(store.length); // alerts '1'\r\nstore.clear();\r\nalert(store.length); // alerts '0'\r\n```\r\n\r\n## Saving the store\r\nWhen you are done writing to the store, call `save` to persist the data to `localStorage`:\r\n\r\n```javascript\r\nstore.save();\r\n```\r\n\r\nIf you don't mind some risk of losing the data, you could bind the `load` and `save` methods\r\nto the `load`, `beforeunload`, `pageshow` and `pagehide` events. Note that WebKit will often\r\nfire both `pagehide` and `beforeunload`, but not always. Currently I feel the best strategy would\r\nbe to bind to all events and just make sure we don't run save twice ourselves.\r\n\r\n\r\n## Beyond the Web Storage API\r\nWebStore is type-agnostic; it doesn't care about the type of data you store. \r\nIf you want to remain within the Web Storage API, you should only read and write strings, \r\nhowever if you want you can store other types just as well.\r\n\r\n### Storing basic types\r\n```javascript\r\nstore.myNumber = 17;\r\nalert(store.myNumber + 3); // alerts '20' (not '173')\r\nstore.myDate = new Date();\r\n\r\nstore.myObject = {my: 'object'};\r\nalert(store.myObject.my); // alerts 'object'\r\nvar tree = {\r\n\tnested: {\r\n\t\tobjects: {\r\n\t\t\tworking: 'Sure!'\r\n\t\t}\r\n\t}\r\n}\r\nstore.setItem('tree', tree);\r\nalert(store.tree.nested.objects.working); // alerts 'Sure!'\r\n```\r\n\r\n###\r\nWebStore even handles custom types:\r\n\r\n```javascript\r\n// A custom type\r\nfunction Greeter(name) {\r\n\tthis.name = name;\r\n\tthis.greet = function Greeter_greet() {\r\n\t\treturn 'Hello, ' + this.name + '!';\r\n\t};\r\n};\r\n\r\n// Add to the store and save\r\nvar store = new WebStore('local');\r\nstore.customData = new Greeter('WebStore');\r\nstore.save();\r\n\r\n// Later on... possibly in a new browsing session\r\nvar store - new WebStore('local');\r\nstore.load();\r\nalert(store.customData.greet()); // alerts 'Hello, WebStore!'\r\n```\r\n\r\n### Dealing with non-public types\r\nWhen saved, WebStore serializes it's data to JSON and saves it in localStorage.\r\nSome extra data is added to allow WebStore to find out what the name was of the\r\nconstructor used to create the object to be stored (class name in Java-speak). \r\nWhen the data is deserialized, WebStore uses JSON.parse with a custom `reviver`\r\nfunction, which can be found on the store config:\r\n\r\n`store.config.reviver;  // --> function basicReviver(key, value)`\r\n\r\nTo restore the original type, WebStore will try to get the constructor from the\r\nwindow object using its name. If your types are not available on the window object, \r\nthere are two thing you can do:\r\n\r\n1. Add the type to the `constructors` object on the basic reviver\r\n2. Replace the basic reviver with your own version.\r\n\r\n#### Adding your private type to the basic reviver\r\nSimply add your constructor function to the `constructors` property on the basic\r\nreviver, keyed by name:\r\n```javascript\r\nfunction MyPrivateConstructor() {\r\n  // do secret stuff here\r\n}\r\n\r\nstore.config.reviver.constructors.MyPrivateConstructor = MyPrivateConstructor;\r\n```\r\n\r\n#### Replacing the basic reviver with your own one.\r\nWriting a good JSON reviver is not easy and out of scope for these docs, \r\nbut once you have one, telling WebStore to use your reviver instead of \r\nthe basic reviver is a one-liner:\r\n\r\n```javascript\r\nvar Store = new WebStore('my-store', {reviver: mySpiffyReviver});\r\n```\r\n\r\nIf you need access to the old reviver, you can pick it up after creating the store\r\nand then assign your new reviver:\r\n\r\n```javascript\r\nvar Store = new WebStore('my-store');\r\nvar oldReviver = store.config.reviver; // Save the old reviver...\r\nstore.config.reviver = mySpiffyReviver; // Assign your new reviver\r\n```\r\n\r\nMake sure you don't save data with one reviver and then attempt to load it with another. It won't work.\r\n\r\n#### Customizing JSON (de)serialization\r\nWebStore adds a property named `__w3cx_ctor__` to the serialized JSON of objects \r\nthat have a custom type, so it's basic reviver knows how to restore them. If you\r\nwant to customize what the JSON looks like, you can do so by implementing a `toJSON`\r\nmethod on your objects, and a `fromJSON` method on your constructor.\r\n\r\n## Copyright\r\nCopyright 2015 by Stijn de Witt. Some rights reserved.\r\n\r\n## License\r\nLicensed under the [Creative Commons Attribution 4.0 International (CC-BY-4.0)](https://creativecommons.org/licenses/by/4.0/) Open Source license.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}